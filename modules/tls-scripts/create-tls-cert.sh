#!/bin/bash
# This script creates a CA cert and a TLS cert signed by that CA, assuming those certs don't already exist. The TLS
# cert is uploaded to AWS Secrets Manager in the region you provide. It is also saved to the tls/ sub-directory.
# Optionally, this script can also upload the cert to ACM, so it can be used with an ELB or ALB.
#
# These certs are meant for private/internal use only, such as to set up end-to-end encryption within an AWS account.
# The only IP address in the cert will be 127.0.0.1 and localhost, so you can test your servers locally. You can also
# use the servers with the ELB or ALB, as the AWS load balancers don't verify the CA.
#
# Note: You must be authenticated to the AWS account for uploading to ACM to work.
#
# Dependencies:
# - aws CLI
# - jq
# Note: These dependencies are automatically included in the Dockerfile in this module folder.

set -e

if [[ -z $AWS_ACCESS_KEY_ID ]] || [[ -z $AWS_SECRET_ACCESS_KEY ]]; then
  echo "ERROR: AWS_ACCESS_KEY_ID or AWS_SECRET_ACCESS_KEY is not set."
  exit 1
fi

readonly script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$script_dir/helpers.sh"

readonly TLS_PATH="/tls/certs"
readonly CERT_PUBLIC_KEY_PATH="${TLS_PATH}/app.crt"
readonly CERT_PRIVATE_KEY_PATH="${TLS_PATH}/app.key"
readonly CA_PUBLIC_KEY_PATH="${TLS_PATH}/CA.crt"

function print_usage {
  log
  log "Usage: create-tls-cert.sh [OPTIONS]"
  log
  log "This script creates a CA cert and a TLS cert signed by that CA, assuming those certs don't already exist. The TLS cert is uploaded to AWS Secrets Manager in the region you provide. It is also saved to the tls/ sub-directory. Optionally, this script can also upload the cert to ACM, so it can be used with an ELB or ALB."
  log
  log "Required Arguments:"
  log
  log "  --secret-name\t\tThe name of the secret you'd like to use to store the cert in AWS Secrets Manager."
  log "  --company-name\t\tThe name of the company this cert is for."
  log "  --cn\t\tThe Common Name (CN) for the certificate: e.g., what domain name to issue it for."
  log "  --country\t\tThe two-letter country code for where your company is located."
  log "  --state\t\tThe two-letter state code for where your company is located."
  log "  --city\t\tThe name of the city for where your company is located."
  log "  --org\t\tThe name of organization in your company."
  log "  --aws-region\t\tThe AWS region to use for AWS Secrets Manager and AWS Certificate Manager."
  log
  log "Optional Arguments:"
  log
  log "  --upload-to-acm\tIf specified, the cert will be uploaded to AWS Certificate Manager and its ARN will be written to stdout."
  log "  --role-arn\t\tThe AWS ARN of the IAM role to assume."
  log
  log "Examples:"
  log
  log "  create-tls-cert.sh \\"
  log "    --secret-name my-tls-secrets \\"
  log "    --company-name Acme \\"
  log "    --country US \\"
  log "    --state AZ \\"
  log "    --city Phoenix \\"
  log "    --org Acme \\"
  log "    --aws-region us-east-1"
  log
  log "  create-tls-cert.sh \\"
  log "    --secret-name my-tls-secrets \\"
  log "    --company-name Acme \\"
  log "    --country US \\"
  log "    --state AZ \\"
  log "    --city Phoenix \\"
  log "    --org Acme \\"
  log "    --aws-region us-east-1 \\"
  log "    --upload-to-acm"
}

# Renders the public and private key as well as the CA public key into a JSON object that is stored in Secrets Manager
function store_tls_certs_in_secrets_manager {
  local -r aws_region="$1"
  local -r secret_name="$2"
  local -r secret_description="The private key generated by create-tls-cert."

  log "Storing TLS Cert in AWS Secrets Manager..."

  local public_key_plaintext
  local private_key_plaintext
  local ca_public_key_plaintext
  local tls_secret_json
  local store_secret_response

  public_key_plaintext=$(cat "${CERT_PUBLIC_KEY_PATH}")
  private_key_plaintext=$(cat "${CERT_PRIVATE_KEY_PATH}")
  ca_public_key_plaintext=$(cat "${CA_PUBLIC_KEY_PATH}")

  tls_secret_json=$(render_tls_secret_json "$public_key_plaintext" "$private_key_plaintext" "$ca_public_key_plaintext")
  store_secret_response=$(store_in_secrets_manager "$secret_name" "$secret_description" "$tls_secret_json" "$aws_region")

  # Extract the ARN of the tls secret in AWS Secrets Manager
  tls_secret_arn=$(echo "$store_secret_response" | jq '.ARN')

  log "TLS Cert stored! Secret ARN: $tls_secret_arn"
}

function upload_to_acm {
  local -r aws_region="$1"
  local -r should_upload_to_acm="$2"

  if [[ "$should_upload_to_acm" != "true" ]]; then
    log "--upload-to-acm flag not set. Will not upload cert to ACM."
    return
  fi

  log "Uploading the certificate to ACM..."

  cert_arn=$(import_certificate_to_acm "$CERT_PUBLIC_KEY_PATH" "$CERT_PRIVATE_KEY_PATH" "$CA_PUBLIC_KEY_PATH" "$aws_region")

  log "Certificate uploaded! Certificate ARN: $cert_arn"
}

function render_tls_secret_json {
  local -r app_public_key="$1"
  local -r app_private_key="$2"
  local -r app_ca_public_key="$3"

  local -r json=$(cat <<END_HEREDOC
{
    "app": {
      "crt": "$app_public_key",
      "key": "$app_private_key",
      "ca": "$app_ca_public_key"
    }
}
END_HEREDOC
)

  echo -n "$json"
}

function do_create {
  local -r company_name="$1"
  local -r aws_region="$2"
  local -r upload_to_acm="$3"
  local -r secret_name="$4"
  local -r country="$5"
  local -r state="$6"
  local -r city="$7"
  local -r org="$8"

  log "Starting TLS cert generation..."

  "generate-self-signed-tls-cert.sh" \
    --cn "$company_name" \
    --country "$country" \
    --state "$state" \
    --city "$city" \
    --org "$org" \
    --dir "${TLS_PATH}" \
    --size 2048 \
    --san "DNS:$company_name,DNS:localhost,IP:127.0.0.1"

  store_tls_certs_in_secrets_manager "$aws_region" "$secret_name"
  upload_to_acm "$aws_region" "$upload_to_acm"

  log "Done with TLS cert generation!"
}

function run {
  local company_name
  local country
  local state
  local city
  local org
  local aws_region
  local role_arn
  local upload_to_acm="false"
  local secret_name

  while [[ $# > 0 ]]; do
    local key="$1"

    case "$key" in
      --upload-to-acm)
        upload_to_acm="true"
        ;;
      --company-name)
        company_name="$2"
        shift
        ;;
      --country)
        country="$2"
        shift
        ;;
      --state)
        state="$2"
        shift
        ;;
      --city)
        city="$2"
        shift
        ;;
      --org)
        org="$2"
        shift
        ;;
      --aws-region)
        aws_region="$2"
        shift
        ;;
      --secret-name)
        secret_name="$2"
        shift
        ;;
      --role-arn)
        role_arn="$2"
        shift
        ;;
      --help)
        print_usage
        exit
        ;;
      *)
        log "Unrecognized argument: $key"
        print_usage
        exit 1
        ;;
    esac

    shift
  done

  assert_not_empty "--company-name" "$company_name"
  assert_not_empty "--country" "$country"
  assert_not_empty "--state" "$state"
  assert_not_empty "--city" "$city"
  assert_not_empty "--org" "$org"
  assert_not_empty "--aws-region" "$aws_region"
  assert_not_empty "--secret-name" "$secret_name"

  assert_is_installed "aws"
  assert_is_installed "jq"

  if [[ ! -z "$role_arn" ]]; then
    assume_iam_role "$role_arn"
  fi

  (do_create "$company_name" "$aws_region" "$upload_to_acm" "$secret_name" "$country" "$state" "$city" "$org")
}

run "$@"
